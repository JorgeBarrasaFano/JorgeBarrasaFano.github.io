<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Mojtaba Barzegari</title>
 <link href="https://mbarzegary.github.io//atom.xml" rel="self"/>
 <link href="https://mbarzegary.github.io//"/>
 <updated>2020-11-11T23:06:37+01:00</updated>
 <id>https://mbarzegary.github.io/</id>
 <author>
   <name></name>
   <email></email>
 </author>

 
 <entry>
   <title>Deriving weak formulation of partial differential equations</title>
   <link href="https://mbarzegary.github.io//2020/11/06/derive-weak-form-pde/"/>
   <updated>2020-11-06T00:00:00+01:00</updated>
   <id>https://mbarzegary.github.io//2020/11/06/derive-weak-form-pde</id>
   <content type="html">&lt;p&gt;The finite element method doesn’t need an introduction, but at the core of this magical method, in its mathematical nature, one challenging step makes it sometimes a bit difficult for newcomers to immediatley jump start and employ finite element to solve partial differential equations (PDEs) numerically. This challenging part is deriving the weak formulation of the PDE, which is indeed one of the very first steps a researcher should take to use the available PDE solvers (like &lt;a href=&quot;https://freefem.org/&quot;&gt;FreeFEM&lt;/a&gt;, &lt;a href=&quot;https://fenicsproject.org/&quot;&gt;FEniCS&lt;/a&gt;, and &lt;a href=&quot;https://www.dealii.org/&quot;&gt;deal.ii&lt;/a&gt;) to simulate a mathematical model.&lt;/p&gt;

&lt;p&gt;Although deriving the weak form of a PDE is relatively simple, finding a good reference that demonstrates how to do it in action for the first time can be a bit difficult. This topic is well covered in most of the finite element books (the ones that discuss the mathematical aspects), but you need to go through a bunch of math to find the most essential steps. In this post, I try to explain this process by deriving the weak form of a reaction-diffusion PDE as an example. The equation we want to deal with is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\partial u}{\partial t}=\nabla \cdot (D   \nabla u)- s u&lt;/script&gt;

&lt;p&gt;in which, &lt;script type=&quot;math/tex&quot;&gt;u=u(\mathbf{x},t)&lt;/script&gt; is the state variable we want to find at each point of space and time. This is also called the strong form of the PDE. To obtain the finite element formulation, the weak form of the PDE is required. In order to get this, we define a space of test functions and then, multiply each term of the PDE by any arbitrary function as a member of this space. The test function space is&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{V}=\left\{v(\mathbf{x}) | \mathbf{x} \in {\Omega}, v(\mathbf{x}) \in \mathcal{H}^{1}(\Omega), \text { and } v(\mathbf{x})=0 \text { on } \Gamma\right\}&lt;/script&gt;

&lt;p&gt;in which the &lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt; is the domain of interest, &lt;script type=&quot;math/tex&quot;&gt;\Gamma&lt;/script&gt; is the boundary of &lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\mathcal{H}^{1}&lt;/script&gt; denotes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sobolev_space&quot;&gt;Sobolev space&lt;/a&gt; of the domain &lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt;, which is a space of functions whose derivatives are square-integrable functions in &lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt;. The solution of the PDE belongs to a trial function space, which is similarly defined as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{S}_{t}=\left\{u(\mathbf{x}, t) | \mathbf{x} \in \Omega, t&gt;0, u(\mathbf{x}, t) \in \mathcal{H}^{1}(\Omega), \text { and } \frac{\partial u}{\partial n}=0 \text { on } \Gamma\right\}.&lt;/script&gt;

&lt;p&gt;Then, we multiply each term of the PDE to an arbitrary function &lt;script type=&quot;math/tex&quot;&gt;v \in \mathcal{V}&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\partial u}{\partial t} v=\nabla \cdot (D  \nabla u) v- s u v.&lt;/script&gt;

&lt;p&gt;Integrating over the whole domain yields:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_{\Omega} \frac{\partial u}{\partial t} v d \omega=\int_{\Omega} \nabla \cdot (D  \nabla u) v d \omega-\int_{\Omega} s u v d \omega.&lt;/script&gt;

&lt;p&gt;The diffusion term can be split using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Integration_by_parts&quot;&gt;integration by parts&lt;/a&gt; technique:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_{\Omega} \nabla \cdot (D  \nabla u) v d \omega = \int_{\Omega} \nabla \cdot[v(D  \nabla u)] d \omega-\int_{\Omega} (\nabla v) \cdot(D  \nabla u) d \omega&lt;/script&gt;

&lt;p&gt;in which the second term can be converted to a surface integral on the domain boundary by applying the &lt;a href=&quot;https://en.wikipedia.org/wiki/Green%27s_theorem&quot;&gt;Green’s divergence theory&lt;/a&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_{\Omega} \nabla \cdot[v(D  \nabla u)] d \omega = \int_{\Gamma} D v \frac{\partial u}{\partial n} d \gamma.&lt;/script&gt;

&lt;p&gt;For the temporal term, we use the finite difference method and apply a first-order &lt;a href=&quot;https://en.wikipedia.org/wiki/Backward_Euler_method&quot;&gt;backward Euler scheme&lt;/a&gt; for discretization, which makes it possible to solve the PDE implicitly:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\partial u}{\partial t} = \frac{u-u^{n}}{\Delta t}&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;u^n&lt;/script&gt; denotes the value of the state variable in the previous time step (or initial condition for the first time step). Inserting all these into the integral form yields:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_{\Omega} \frac{u-u^{n}}{\Delta t} v d \omega=\int_{\Gamma} D v  \frac{\partial u}{\partial n} d \gamma-\int_{\Omega} D  \nabla u \cdot \nabla v d \omega-\int_{\Omega} s u v d \omega.&lt;/script&gt;

&lt;p&gt;The surface integral is zero because there is a no-flux boundary condition on the boundary of the computational domain (defined in the trial function space). By reordering the equation, we get:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_{\Omega} \frac{u}{\Delta t} v d \omega+\int_{\Omega} D \cdot \nabla \cdot u \nabla v d \omega+\int_{\Omega} s u v d \omega=\int_{\Omega} \frac{u^{n}}{\Delta t} v d \omega&lt;/script&gt;

&lt;p&gt;which is the weak form of the PDE and can be written as (by multiplying to &lt;script type=&quot;math/tex&quot;&gt;\Delta t&lt;/script&gt;):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_{\Omega} {u} v d \omega+\int_{\Omega} \Delta t D  \nabla u \cdot  \nabla v d \omega+\int_{\Omega} \Delta t s u v d \omega=\int_{\Omega} {u^{n}} v d \omega.&lt;/script&gt;

&lt;p&gt;So, the problem is finding a function &lt;script type=&quot;math/tex&quot;&gt;u(t) \in \mathcal{S}_{t}&lt;/script&gt; such that for all &lt;script type=&quot;math/tex&quot;&gt;v \in \mathcal{V}&lt;/script&gt; the above equation would be satisfied. Defining and solving this problem is simple and straightforward in a wide variety of available finite element PDE solvers such as FreeFEM.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Building OpenFOAM in a Conda virtual environment</title>
   <link href="https://mbarzegary.github.io//2020/10/18/build-openfoam-in-conda-environment/"/>
   <updated>2020-10-18T00:00:00+02:00</updated>
   <id>https://mbarzegary.github.io//2020/10/18/build-openfoam-in-conda-environment</id>
   <content type="html">&lt;p&gt;In &lt;a href=&quot;/2020/10/10/using-conda-as-a-build-environment/&quot;&gt;previous post&lt;/a&gt;, I explained why a Conda environment would be interesting for building software programs in an isolated box. In this post, as an example, I describe how it works if we want to build &lt;a href=&quot;https://openfoam.org/&quot;&gt;OpenFOAM&lt;/a&gt; in this manner. As I said, the main advantage of doing this is the possibility of building/installing software without the root privilege, a scenario that happens frequently while working with clusters and supercomputers. A root previlege is required for following the &lt;a href=&quot;https://openfoam.org/download/source/&quot;&gt;official build procedure for OpenFOAM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The following procedure is independent of the underlying Linux installation, and only a tool to download Miniconda and a text editor suffice (here I have used &lt;code class=&quot;highlighter-rouge&quot;&gt;wget&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;nano&lt;/code&gt; for these purposes). Also, it’s worth mentioning that all the paths are taken from my system, so throughout the tutorial, make sure to double-check all the paths/directories to make sure that they match your system configuration. The tutorial is prepared for &lt;code class=&quot;highlighter-rouge&quot;&gt;bash&lt;/code&gt;, but the approach should be more or less the same for other shells and can be modified accordingly&lt;/p&gt;

&lt;p&gt;Okay, the first step is to download and install Conda. I personally prefer &lt;a href=&quot;https://docs.conda.io/en/latest/miniconda.html&quot;&gt;Miniconda&lt;/a&gt; over a full &lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt; installation, which usually leaves you with a bunch of unused packages and a tremendous amount of disk usage. Miniconda provides you with a minimal installation of Conda, and you can use it to download the necessary packages only. So, let’s download the installer and run it.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;bash Miniconda3-latest-Linux-x86_64.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Follow the onscreen instruction. In the last step, you may choose to auto-initialize the base environment every time you open your BASH session. Doing this saves you from doing some extra steps to add the &lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; executable path to the &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; environment variable, so it’s better to let the installer add the appropriate statements to your profile’s &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt;. If not, execute this command after adding the bin folder to &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; and restarting your session:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda init bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, now, Conda is fully under our control to follow our orders. Let’s create a virtual environment. We call it “gcc” just because we want to use &lt;a href=&quot;https://gcc.gnu.org/&quot;&gt;GNU Compiler Collection&lt;/a&gt; to build things.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda create &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; gcc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By activating the environment, we isolate ourselves from the rest of the system. Let’s do it.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda activate gcc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Okay, it’s time to install all the prerequisites in the virtual environment. It will be as easy as calling &lt;code class=&quot;highlighter-rouge&quot;&gt;conda install&lt;/code&gt; command.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda activate gcc
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;gcc_linux-64
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;gxx_linux-64
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;gfortran_linux-64
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;cmake
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;openmpi
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;flex
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;bison
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;boost
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;curl
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;conda &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Although this is something done automatically, let’s double-check that the gcc bundled scripts are run to change the build environment variables (like &lt;code class=&quot;highlighter-rouge&quot;&gt;$CC&lt;/code&gt;) to point to the compilers installed inside the virtual environment.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ $CONDA_PREFIX&lt;/span&gt;/etc/conda/activate.d/activate-gcc_linux-64.sh
&lt;span class=&quot;nv&quot;&gt;$ $CONDA_PREFIX&lt;/span&gt;/etc/conda/activate.d/activate-gxx_linux-64.sh
&lt;span class=&quot;nv&quot;&gt;$ $CONDA_PREFIX&lt;/span&gt;/etc/conda/activate.d/activate-gfortran_linux-64.sh
&lt;span class=&quot;nv&quot;&gt;$ $CONDA_PREFIX&lt;/span&gt;/etc/conda/activate.d/activate-binutils_linux-64.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In a standard world, everything should be ready till now, and software build routines should look for the environment variables to find the appropriate compilers. For example, a standard build command in a makefile should be something like &lt;code class=&quot;highlighter-rouge&quot;&gt;$CC source.c&lt;/code&gt; and not &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc source.c&lt;/code&gt;. But, we don’t live in such a world, and it means that not every single piece of software follows this principle. Unfortunately, OpenFOAM is not an exception in this regard, and its build routine calls the compilers’ executable directly. This creates an issue for our approach because it indeed calls the system compilers (if they are installed) and not the ones we have installed in our virtual environment. This is highly dangerous for our case, so let’s create some soft links to ask BASH to compensate.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$CONDA_PREFIX&lt;/span&gt;/bin/
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-gcc gcc
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-g++ g++
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-c++ c++
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-gfortran gfortran
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-ld ld
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-as as
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-nm nm
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-cpp cpp
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-ld.bfd ld.bfd
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-ld.gold ld.gold
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; x86_64-conda_cos6-linux-gnu-ar ar
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, if you run &lt;code class=&quot;highlighter-rouge&quot;&gt;which gcc&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;which g++&lt;/code&gt;, you should see it pointing to the virtual environment compilers. Yes? So, let’s go on by cloning the source codes and do the actual build.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;openfoam
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;openfoam/
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/OpenFOAM/OpenFOAM-8.git
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/OpenFOAM/ThirdParty-8.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;OpenFOAM comes with its own way of initializing things in BASH, and we need to follow its principle. No problem man, we will.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source &lt;/span&gt;OpenFOAM-8/etc/bashrc
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;ThirdParty-8/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cool. It’s time to start the build by typing &lt;code class=&quot;highlighter-rouge&quot;&gt;./Allwmake&lt;/code&gt;, no? No, it’s not. If you proceed, you will face lots of compiling/linking errors. It’s because we have installed all the required libraries inside the Conda environment (and not the known system directories like &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/include&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib&lt;/code&gt;). We should tell the compiler where to seek them. This is also something that should be solved in a standard way, but (not surprisingly) going for conventional things doesn’t work for OpenFOAM. As a result, we edit the config files directly. A horrible idea, but something that usually works for such issues. Let’s edit the “Scotch” build config to tell it where to find the “zlib” library. Run this command:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nano etc/wmakeFiles/scotch/Makefile.inc.i686_pc_linux2.shlib-OpenFOAM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and append these lines to its end:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CFLAGS  += -I /home/mojtaba/miniconda3/pkgs/zlib-1.2.11-h7b6447c_3/include 
LDFLAGS += -L /home/mojtaba/miniconda3/pkgs/zlib-1.2.11-h7b6447c_3/lib
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Make sure to adapt the directories to something that matches your system paths. And now, we are ready to start building the third-party tools for OpenFOAM (which is literally just the Scotch library as we don’t intend to build ParaView).&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./Allwmake
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, we refresh the OpenFOAM variables and go to the main source directory.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wmRefresh
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ../OpenFOAM-8/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We should perform some more modifications here (pay attention to the paths and adapt them before saving the files). Run:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nano wmake/rules/linux64Gcc/c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and add this to the end:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CFLAGS += -I /home/mojtaba/miniconda3/pkgs/zlib-1.2.11-h7b6447c_3/include -I /home/mojtaba/miniconda3/pkgs/flex-2.6.4-ha10e3a4_1/include/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Do a similar thing for the C++ compiler flags:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nano wmake/rules/linux64Gcc/c++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and add:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c++FLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-I&lt;/span&gt; /home/mojtaba/miniconda3/pkgs/zlib-1.2.11-h7b6447c_3/include &lt;span class=&quot;nt&quot;&gt;-I&lt;/span&gt; /home/mojtaba/miniconda3/pkgs/flex-2.6.4-ha10e3a4_1/include/
c++FLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wl&lt;/span&gt;,-rpath-link,/home/mojtaba/openfoam/ThirdParty-8/platforms/linux64Gcc/gperftools-svn/lib 
c++FLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wl&lt;/span&gt;,-rpath-link,/home/mojtaba/openfoam/OpenFOAM-8/platforms/linux64GccDPInt32Opt/lib/openmpi-system 
c++FLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wl&lt;/span&gt;,-rpath-link,/home/mojtaba/openfoam/ThirdParty-8/platforms/linux64GccDPInt32/lib/openmpi-system 
c++FLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wl&lt;/span&gt;,-rpath-link,/home/mojtaba/openfoam/site/8/platforms/linux64GccDPInt32Opt/lib 
c++FLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wl&lt;/span&gt;,-rpath-link,/home/mojtaba/openfoam/OpenFOAM-8/platforms/linux64GccDPInt32Opt/lib 
c++FLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wl&lt;/span&gt;,-rpath-link,/home/mojtaba/openfoam/ThirdParty-8/platforms/linux64GccDPInt32/lib 
c++FLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wl&lt;/span&gt;,-rpath-link,/home/mojtaba/openfoam/OpenFOAM-8/platforms/linux64GccDPInt32Opt/lib/dummy
c++FLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wl&lt;/span&gt;,-rpath-link,/home/mojtaba/miniconda3/pkgs/zlib-1.2.11-h7b6447c_3/lib
c++FLAGS +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-Wl&lt;/span&gt;,-rpath-link,/home/mojtaba/miniconda3/envs/gcc/lib
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And the last one, which is a little bit tricky (because &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; is sensitive to indentation and you should pay attention to not ruin the structure of the file), is to help the linker find “zlib” again. Run this:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nano src/OpenFOAM/Make/options
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and modify the &lt;code class=&quot;highlighter-rouge&quot;&gt;LIB_LIBS&lt;/code&gt; variable to look like this (it’s safer to gather them all in one line to avoid mistakes):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LIB_LIBS = $(FOAM_LIBBIN)/libOSspecific.o -L$(FOAM_LIBBIN)/dummy -lPstream -L /home/mojtaba/miniconda3/pkgs/zlib-1.2.11-h7b6447c_3/lib -lz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Okay, so we are all set to continue. Let’s run the build command:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./Allwmake &lt;span class=&quot;nt&quot;&gt;-j&lt;/span&gt; 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You should adjust the number of CPU cores you want to employ (which implies the number of concurrent compile commands running at the same time). The more, the better. I had 8 free cores, so I have entered 8 here. It may take up to several hours if you run it without the &lt;code class=&quot;highlighter-rouge&quot;&gt;-j&lt;/code&gt; flag, but for example, with 8 parallel cores, it took less than one and a half hours to finish.&lt;/p&gt;

&lt;p&gt;If it succeeds (which should be the case), we can go on to test if it really works by copying one of the OpenFOAM tutorials and running it.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ..
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;tests
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;tests/
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$FOAM_TUTORIALS&lt;/span&gt;/incompressible/simpleFoam/pitzDaily &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;pitzDaily/
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;blockMesh
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;simpleFoam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You should see the OpenFOAM simulation running. And that’s it. Relatively straightforward, no? To use it next time you open a BASH session, you should activate the virtual environment again (&lt;code class=&quot;highlighter-rouge&quot;&gt;conda activate gcc&lt;/code&gt;) and run the initialization script (&lt;code class=&quot;highlighter-rouge&quot;&gt;source OpenFOAM-8/etc/bashrc&lt;/code&gt;), and there you go.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Using Conda as a build environment for Linux</title>
   <link href="https://mbarzegary.github.io//2020/10/10/using-conda-as-a-build-environment/"/>
   <updated>2020-10-10T00:00:00+02:00</updated>
   <id>https://mbarzegary.github.io//2020/10/10/using-conda-as-a-build-environment</id>
   <content type="html">&lt;p&gt;When it comes to installing software programs and libraries on Linux, compiling from source code is a first-class citizen. I mean it’s the most preferred way and has been there to save lots of time from software developers to meet the different requirements of different hardware/software configurations on a wide variety of Linux distributions. This process has its own challenges, especially in case of installing and satisfying the required dependencies, a task that can be quite nightmarish (of course not as bad as as the nostalgic &lt;a href=&quot;https://en.wikipedia.org/wiki/DLL_Hell&quot;&gt;DLL hell&lt;/a&gt; in Windows). It can get even worse when you don’t have root access to install the dependencies, which happens every now and then in daily life of a computational researcher when he/she wants to do this on a remote cluster or a university supercomputer.&lt;/p&gt;

&lt;p&gt;A potential solution to this issue is taking advantage of container technologies like &lt;a href=&quot;https://docs.docker.com/get-started/&quot;&gt;Docker&lt;/a&gt; or &lt;a href=&quot;https://singularity.lbl.gov/quickstart&quot;&gt;Singularity&lt;/a&gt;, but what if we don’t have access to these packages as well? True, the most trivial solution would be compiling all the dependencies also from source code, but you should go for it only if you have super “enough time” as it can be an endless task. This is something I did once to build &lt;a href=&quot;https://freefem.org/&quot;&gt;FreeFEM&lt;/a&gt; on an old cluster, and to be honest, it was something I will never go for that again because it required me to compile not only all the dependencies but the compilers as well (a process called “&lt;a href=&quot;https://en.wikipedia.org/wiki/Bootstrapping_(compilers)&quot;&gt;Bootstrapping&lt;/a&gt;”). By the way, that was fun enough to be told later, and yes, I should write about it at some point.&lt;/p&gt;

&lt;p&gt;So, is there any other option? Yes, there is. Although people know it as a virtual environment manager for Python, &lt;a href=&quot;https://docs.conda.io/en/latest/&quot;&gt;Conda&lt;/a&gt; can be used in a more generalized manner, and it can be a lifesaver for the aforementioned issue as it provides a fully isolated environment (like containers but without living directly on the kernel) to install the required libraries and compilers. Above this all, it’s very easy to install Conda on a Linux system without the root privilege and any previous software dependency. Yes, what can be better than that?&lt;/p&gt;

&lt;p&gt;Technically speaking, compiling things on a Conda environment can be considered as “pseudo-cross-compiling”, a sub-category of “&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross_compiler&quot;&gt;cross-compiling&lt;/a&gt;” (a common term you may frequently hear about in the field of embedded systems in which you compile a program on a system but run it somewhere else on a different architecture). But, I cannot describe pseudo-cross-compiling better than how the Anaconda team has documented it in &lt;a href=&quot;https://docs.conda.io/projects/conda-build/en/latest/resources/compiler-tools.html&quot;&gt;Anaconda compiler tools&lt;/a&gt;, so I just quote the relevant part here:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Anaconda’s compilers for Linux are built with something called crosstool-ng. They include not only GCC but also a “sysroot” with glibc, as well as the rest of the toolchain (binutils). Ordinarily, the sysroot is something that your system provides, and it is what establishes the libc compatibility bound for your compiled code. Any compilation that uses a sysroot other than the system sysroot is said to be “cross-compiling.” When the target OS and the build OS are the same, it is called a “pseudo-cross-compiler”. This is the case for normal builds with Anaconda’s compilers on Linux.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It’s very cool, isn’t it?&lt;/p&gt;

&lt;p&gt;A couple of weeks ago, a colleague of mine asked me for a solution to install &lt;a href=&quot;https://openfoam.org/&quot;&gt;OpenFOAM&lt;/a&gt; on a cluster on which he didn’t have root privilege. OpenFOAM has a straightforward &lt;a href=&quot;https://openfoam.org/download/source/&quot;&gt;installation procedure from the source code&lt;/a&gt; but the thing is it requires root privileges to install required dependencies, which is obviously not possible in this case. So, I tried Conda for the first time for this purpose, and indeed, it  worked like a charm for us. Yes, it was a bit challenging to make it work (which I should write about in a separate post), but it helped us to compile a complex software from scratch totally independent from the underlying OS and its configurations. In the next post, I will document the procedure in detail as an example of this approach.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Flexibility of having multiple parallel instances of Linux using WSL</title>
   <link href="https://mbarzegary.github.io//2020/09/29/wsl-multi-instance/"/>
   <updated>2020-09-29T00:00:00+02:00</updated>
   <id>https://mbarzegary.github.io//2020/09/29/wsl-multi-instance</id>
   <content type="html">&lt;p&gt;Working with Windows can be truly a nightmare in scientific computing projects. The main reason behind this is that most of the scientific computing libraries have developed natively for Linux, and in the case of cross-platform ones, the building and installation process on Linux is more straightforward and easy to accomplish. In addition to this, the freedom you have while working with the command line interface can never be experienced in Windows with PowerShell or the traditional Command Prompt.&lt;/p&gt;

&lt;p&gt;So why are we talking about this when Linux is there and we don’t need to stick to Windows? The problem arises when you work for a big organization that doesn’t allow Linux to be installed on your machine because all the operational workflow, communication systems, and things like that are going to take place in Windows (which is indeed my case at KU Leuven, although I have installed an ILLEGAL dual boot version of Linux by bypassing the organizational Bitlocker, but it’s not always feasible and convenient to reboot to Windows to join a meeting, sign something or print a document).&lt;/p&gt;

&lt;p&gt;The solution to this problem was released by Microsoft several years ago, a feature of Windows called &lt;a href=&quot;https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux&quot;&gt;Windows Subsystem for Linux (WSL)&lt;/a&gt;, providing you with an emulated Linux kernel on top of which you can install your favorite distribution. It gives you full terminal access as well as limited support for running graphical applications (with some tricks of course). Recently, they have also extended and upgraded this feature to a real Linux kernel in WSL 2 (which I haven’t tested yet), which has also some cool and long awaited features such as GPU support.&lt;/p&gt;

&lt;p&gt;But, beside this, WSL can be tweaked to bring even more productivity especially if you want to test multiple libraries and different configurations without touching your previous working instances of configured Linux (which indeed happens every now and then in scientific computing). Doing this in a native installation of Linux (like with &lt;code class=&quot;highlighter-rouge&quot;&gt;chroot&lt;/code&gt;) requires some effort. Having multiple instances of the same Linux distribution in WSL is not supported out-of-the-box but can be accomplished using a less-known, yet fantastic tool called &lt;a href=&quot;https://github.com/DDoSolitary/&quot;&gt;LxRunOffline&lt;/a&gt;. The simplest way to install LxRunOffline is by downloading the compiled binaries from GitHub. Adding the executable path to the “Path” environment variable is highly recommended. After doing that, a new instance can be installed as simple as:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; LxRunOffline i -n &amp;lt;name_of_the_instance&amp;gt; -d &amp;lt;isntallation_location&amp;gt; -f &amp;lt;path_of_the_downloaded_image&amp;gt; -s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;in which the &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; argument indicates the installation action (to see all available operations, execute &lt;code class=&quot;highlighter-rouge&quot;&gt;LxRunOffline&lt;/code&gt; without any action). Then, the installed instance can be run using:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; LxRunOffline r -n &amp;lt;name_of_the_instance&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You can encapsulate this command in a batch file, which can be placed on Desktop (or even better somewhere in “Path”, so you can run it directly from Command Prompt in any directory) for an easier access.&lt;/p&gt;

&lt;p&gt;And now, the great flexibility comes with the freedom of choosing whatever you want as the distribution. What I use most often for this purpose is &lt;a href=&quot;https://ubuntu.com/core&quot;&gt;Ubuntu Core&lt;/a&gt;, a light-weight Linux distribution aimed for IoT devices, but with APT package manager installed, which enables me to start with a tiny Linux installation, and then configure it to fit my needs. By doing this, I can quickly have a fresh installation of Linux to test or run something without affecting the previous configurations I have. A wide variety of Ubuntu Core images can be downloaded &lt;a href=&quot;https://partner-images.canonical.com/core/&quot;&gt;here&lt;/a&gt;. A typical command for such a purpose can be then something like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; LxRunOffline i -n ubuntu-4.6 -d c:\wsl\ubuntu-test46 -f ubuntu-bionic-core-cloudimg-amd64-root.tar.gz -s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
 </entry>
 

</feed>
